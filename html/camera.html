<!DOCTYPE html>
<head>
    <link rel="stylesheet" href="../css/camera.css" type="text/css"/>
</head>
<body>
  <!-- <div id="cameraView"></div> -->
     
    <video id="my_video" autoplay playsinline >
    </video>
    <canvas id="picture"></canvas>
    
    <img id="black_rect" src="../picture/page48/Rectangle 185.png">
    <img id="open_webcam" src="../picture/page48/Group 186.png">
    <img id="photo" src="../picture/page48/Mask group.png" >
    <img id="sharebackground" src="../picture/page48/13 Pro - 31.png" style="visibility: hidden;">
    <button id="again" style="visibility: hidden;">再拍一次</button>
</body>
<script>
    //  Webcam.set({
    //   width: 320,
    //   height: 240,
    //   dest_width: 640,
    //   dest_height: 480,
    //   image_format: 'jpeg',
    //   jpeg_quality: 90
    // });
    // Webcam.attach('#cameraView');

    const video_el = document.getElementById("my_video");
    var  canvas_el = document.getElementById("picture");
    var photo = document.getElementById("photo");
    var black = document.getElementById("black_rect");
    var share = document.getElementById("sharebackground");
    var again = document.getElementById("again");

      
      var constrain ={audio:false,
                      video:{
                        width: { min:  360, ideal: 360},//this.height,
                        height: { min:  780, ideal: 780 },
                        facingMode:"user" //this.width    
                         }}
      var stream_obj; // 預計用來存放 串流相關的物件(MediaStream)

      
      
      
      // 開啟 webcam
      const open_webcam_el = document.getElementById("open_webcam");
      
        
        // 開啟視訊鏡頭，瀏覽器會跳詢問視窗
        navigator.mediaDevices.getUserMedia(constrain).then(function(stream){
          stream_obj = stream;         // 將串流物件放在 stream_obj 全域變數，方便後面關閉 webcam 時會用到
          video_el.srcObject = stream; // video 標籤顯示 webcam 畫面
        }).catch(function(error){      // 若無法取得畫面，執行 catch
          console.log('navigator.MediaDevices.getUserMedia Error: ', error.message, error.name);
        });
        
      open_webcam_el.addEventListener("click", function(){
        stream_obj.getTracks().forEach(function(track) {
          track.stop();
        });

        stream_obj = undefined;    // 回到該變數原來預設(即 undefined)
        // video_el.srcObject = null; // 將 video 標籤上的 srcObject 清空
        canvas_el.width = video_el.videoWidth;
        canvas_el.height = video_el.videoHeight;
        canvas_el.getContext('2d').drawImage(video_el, 0, 0, canvas_el.width, canvas_el.height);
        canvas_el.getContext('2d').drawImage(photo, 0, 0, canvas_el.width, canvas_el.height);
        
        black.setAttribute('style','visibility:hidden');
        open_webcam_el.setAttribute('style','visibility:hidden');
        photo.setAttribute('style','visibility:hidden');
        again.setAttribute('style','none');
        // share.setAttribute('style','none');
        
        again.addEventListener('click',function(){
          var  canvas_el = document.getElementById("picture");
          again.setAttribute('style','visibility:hidden');
          black.setAttribute('style','none');
          open_webcam_el.setAttribute('style','none');
          context = canvas_el.getContext('2d');
          context.clearRect(0, 0, canvas_el.width, canvas_el.height);
          navigator.mediaDevices.getUserMedia(constrain).then(function(stream){
          stream_obj = stream;         // 將串流物件放在 stream_obj 全域變數，方便後面關閉 webcam 時會用到
          video_el.srcObject = stream; // video 標籤顯示 webcam 畫面
        }).catch(function(error){      // 若無法取得畫面，執行 catch
          console.log('navigator.MediaDevices.getUserMedia Error: ', error.message, error.name);
        });
           })
        
           
      });

</script>
</html>